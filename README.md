Архитектура системы
text
IoT устройства → RabbitMQ → Основное приложение → База данных
Подробное объяснение каждого теста:
Тест 1: RabbitMQ
bash
docker-compose up -d
docker ps
Что происходит:

Запускается контейнер с RabbitMQ (брокер сообщений)

RabbitMQ выступает в роли "почтового отделения" для IoT-данных

Создается очередь sensor_data для временного хранения сообщений

Ожидаемый результат: Контейнер iot-rabbitmq в статусе "Up"

Тест 2: Основное приложение
bash
cd application
python main.py
Что происходит:

Запускается основной обработчик данных

Приложение подключается к RabbitMQ

Начинает "слушать" очередь sensor_data

Инициализируются все компоненты:

Потребитель сообщений из RabbitMQ

Модуль обработки данных

Модуль записи в базу данных

Ожидаемый результат: "All components initialized"

Тест 3: Прием данных
bash
python test_client.py
Что происходит:

Имитируется работа IoT-устройства

Генерируются тестовые данные (температура, влажность и т.д.)

Данные отправляются в очередь RabbitMQ в формате JSON:

json
{
  "sensor_id": "sensor_001",
  "temperature": 23.5,
  "humidity": 45.0,
  "timestamp": "2024-01-15T10:30:00"
}
Основное приложение получает эти данные из очереди

Ожидаемый результат: "Data sent and processed"

Тест 4: База данных
bash
python check_database.py
Что происходит:

Проверяется, что данные действительно сохранились

Выполняется SQL-запрос к таблице sensor_data:

sql
SELECT * FROM sensor_data;
Проверяется целостность данных и корректность записи

Ожидаемый результат: Найденные записи в таблице

Тест 5: RabbitMQ Web UI
text
http://localhost:15672 (admin/password)
Что происходит:

Открывается веб-интерфейс управления RabbitMQ

Можно визуально увидеть:

Очередь sensor_data

Количество сообщений (готовых и обработанных)

Статус подключений

Поток данных в реальном времени

Ожидаемый результат: Очередь существует и содержит сообщения

Преимущества такой архитектуры:
Отказоустойчивость - данные не теряются при перезапуске приложения

Масштабируемость - можно добавить больше IoT-устройств и обработчиков

Асинхронность - устройства не ждут обработки данных

Надежность - сообщения сохраняются до подтверждения обработки

Это типичная архитектура для систем сбора данных, где важна надежность и возможность обработки пиковых нагрузок.